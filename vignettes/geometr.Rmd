---
title: "geometr - An overview"
author: "Steffen Ehrmann"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction
  
The `geometr` package provides tools that generate and process fully accessible and tidy geometric shapes (of class `geom`). Moreover, `geometr` aims to improve interoperability of spatial classes. Spatial classes are typically a collection of geometric shapes (or their vertices) that are accompanied by various metadata (such as attributes and a coordinate reference system). Most spatial classes are thus conceptually quite similar, yet a common standard lacks for accessing features, vertices or the metadata.

This vignette outlines in more detail first how `geometr` improves interoperability, then it scrutinises the datastructure of a `geom` (the spatial class that comes with `geometr`) and how different types are cast into one another, shows how to visualise spatial objects and eventually gives a short introduction of some of the tools that come with `geometr`.


## Interoperability

Interoperable software is software that can easily exchange information with other software, which is typically achieved by providing the output of functionally similar operations in a common arrangement or format.
This principle is not only true for software written in different language, but can also apply, for instance, to several packages within the R ecosystem.
R is an open source environment which means that no single package or class will ever be the sole source of a particular datastructure and this is also the case for spatial or geometric data.

Interoperable data is data that has a common arrangement and that uses terms from the same vocabulary.
We can think, for example, of the extent of a spatial or geographic object.
An extent is characterised by a minimum and maximum value in all valid dimensions.
There are, however, several data structures in which the information can be reported, such as a vector of several numbers or a table.
Moreover, the data carried by disparate data structures may not be provided so that the same information is at the same position in all structures.

The following code section shows various functions, which are all considered standard in R to date, that derive an extent from specific spatial objects:

```{r}
library(sf)
nc_sf <- st_read(system.file("shape/nc.shp", package="sf"))
st_bbox(nc_sf)

library(sp)
nc_sp <- as_Spatial(nc_sf)
bbox(nc_sp)

library(raster)
ras <- raster(system.file("external/test.grd", package="raster"))
extent(ras)
```

`st_bbox()` provides the information as a named vector, and presents first minimum and then maximum values of both dimensions, `bbox()` provides a table with minimum and maximum values in columns and `extent()` provides the information in an S4 object that presents first the x and then the y values.
Neither data structures, nor names or positions of the information are comparable, which requires distinct procedures to extract one and the same information from those outputs.

For a human user the structure of those information might not matter.
However, the capacity of humans to recognise information relative to their context needs to be programmed into the software that is supposed to gather information with respect to context.
Think, for example, of a custom function that is designed to derive and process information from some arbitraty spatial input a user provides, without knowing in advance what spatial class the user will provide.
This would require an extensive code-logic to handle all possible input formats, complicated further by classes that may become available only in the future.

`geometr` improves interoperability in R for spatial classes by following the [Bioconductor standard for S4 classes](https://www.bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html#api-vs-internals).
Here, *getters* and *setters* are used as accessor functions, and as the sole pathway to extract or modify information in a given data structure.
`geometr` thus provides getters that provide information in identical format from a wide range of classes, and likewise setters that modify many different classes in the same way, despite those classes typically need differently formatted input, arguments and functions.

```{r}
library(geometr)
myInput <- nc_sf
getExtent(x = myInput)

myInput <- nc_sp
getExtent(x = myInput)

myInput <- ras
getExtent(x = myInput)
```

The output of the tools provided by `geometr` is tidy, i.e. it provides variables in columns and observations in rows, and it is interoperable, i.e. it provides the same information in the same spot of the output object, with the same names.
This ensures, amongst other advantages, that a custom function that processes spatial information, requires merely one very simple row of code to extract those information from a potentially wide range of distinct classes.

## Datastructure of the class `geom`

- three feature types
- all types have the same datastructure (i.e. it's interoperable, no slots are removed or added when modifying things)
- three tables, vertices, features and groups all can be joined with ancilliary data
- has a scale, which is either absolute or relative, the latter case then contains vertices relative to the reference window
- has a history slot that contains the provenance of a geom
- features are single closed paths
- multi* features are transformed to several (simpler) features and assigned the same group (some reasoning on that)
- geom contains only direct information, i.e. such information that can't be derived for example the extent
- has a reference window instead of an extent (like in spatstat)
- talk about tiny map
- talk about which advantages that brings, vertices are easily accessible and can be provided with attributes, which allows also point patterns to be treated together with other geometries
- somehow a hybrid of ppp and sf (units as in spatstat are indirectly covered by the projection)
- also describe that how a single features looks like (being close by a duplicate vertex and with holes that are inside)
- when making a geom from an sf, group = TRUE can be used to assign values that are unique at the level of multi_ features, into the groups attribute table, and not into the features attribute table, where they would be duplicated in a geom.
- the vert slot is comparable to the "geom" column in an sf, however, the values are easily and explicitly accessible and can be modified also with other functions or routines than the highly specific st_* functions.


## Casting

- cast by providing a geom in anchor of the respecive type
- it does not change anything about the data (check if that claim is really true), but merely changes the type.
- the type then determines how the object is plotted.
- when casting to polygon, the polygon checks are carried out.

## Visualising

- plot objects by providing a "the name = theObject".
- plot both, vector and raster objects
- methods extract the required information based on the above discussed getters, for any class that has getters defined (this still requires some work to be true for all classes)

### Quick options

- attributes can be used in quick options

### The `gtTheme`

- explain how to set up a gtTheme
- there is a default gtTheme, which is modified with setTheme, which is kind of a setter, just not for geoms, but for gtTheme.
- explain how colour palettes work.

## Other tools in `geometr`

- tools are used feature-wise, if more than one set of modification values is provided. for example, if there are two features and two distinct angles of ration are provided, each feature will be rotated by the respective angle. When there are more features than angles, angles will be recycled.
- mention that those functions access the vertices