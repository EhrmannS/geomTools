---
title: "geometr - An overview"
author: "Steffen Ehrmann"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
## ToDo

- replace all "spatial" by "geometric"
- also mention gt_sketch somewhere.

## Introduction
  
The `geometr` package provides tools that generate and process fully accessible and tidy geometric shapes (of class `geom`). 
Moreover, `geometr` aims to improve interoperability of geometric classes. 
One could argue that spatial classes are merely a special case of geometric classes, where the vertices refer to real locations on the surface of the earth, specified in further detail by the coordinate reference system (crs) [REF].
For ordinary geometric shapes (such as squares or circles), the coordinate (reference) system is the *cartesian coordinate system*.
`geometr` makes this generalisation and treats all geometric and spatial classes in the same way, hence, the further text refers to both, geometric and spatial classes with the term *geometric classes*.
Geometric objects are typically a collection of geometric shapes, which are called *features* here, or the vertices that outline the shapes.
They are often accompanied by various metadata, such as properties of the class of geometric object, feature attributes or a coordinate reference system. 
Most geometric classes are thus conceptually quite similar, yet a common, interoperable standard lacks for accessing and modifying features, vertices or the metadata.

This vignette outlines in detail first how `geometr` improves interoperability, then it scrutinises the datastructure of a `geom` (the spatial class that comes with `geometr`) and how different types are cast into one another, shows how to visualise spatial objects and eventually gives a short introduction of initial tools that come with `geometr`.


## Interoperability

Interoperable software can easily exchange information with other software, which is typically achieved by providing the output of functionally similar operations in a common arrangement or format [REF].
This principle is not only true for software written in different language, but can also apply, for instance, to several packages within the R ecosystem.
R is an open source environment which means that no single package or class will ever be the sole source of a particular datastructure and this is also the case for geometric data.

Interoperable data is data that has a common arrangement and that uses terms from the same vocabulary [REF].
We can think, for example, of the extent of a geometric object.
An extent is characterised by a minimum and maximum value in all valid dimensions.
There are, however, several data structures in which the information can be reported, such as a vector of several numbers or a table.
Moreover, distinct data structures may provided data so that the same information is not at the same location or with the same name in all structures, e.g., the minimum value of the x dimension is not always the first information and is not always called 'xmin'.

The following code chunk shows various functions, which are all considered standard in R to date, that derive an extent from specific spatial objects:

```{r}
library(sf)
nc_sf <- st_read(system.file("shape/nc.shp", package="sf"))
st_bbox(nc_sf)

library(sp)
nc_sp <- as_Spatial(nc_sf)
bbox(nc_sp)

library(raster)
ras <- raster(system.file("external/test.grd", package="raster"))
extent(ras)
```

`st_bbox()` provides the information as a named vector, and presents first minimum and then maximum values of both dimensions, `bbox()` provides a table with minimum and maximum values in columns and `extent()` provides the information in an S4 object that presents first the x and then the y values.
Neither data structures, nor names or positions of the information are comparable.

For a human user the structure of those information might not matter, because we recognise, in most cases intuitively, where which information is to be found in a datastructure.
In the above case it is easiy to recognise how the combination of column and rownames (of `bbox()`) refers to the already combined names (of `st_bbox()` or `extent()`).
However, this capacity of humans to recognise information relative to the context needs to be programmed into software, for it to have that ability.
Think, for example, of a custom function that is designed to extract and process information from an arbitraty spatial input, i.e., without knowing in advance what spatial class the user will provide. 
This would require an extensive code-logic to handle all possible input formats, complicated further by classes that may become available only in the future.

`geometr` improves interoperability in R for spatial classes by following the [Bioconductor standard for S4 classes](https://www.bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html#api-vs-internals).
Here, *getters* and *setters* are used as accessor functions, and as pathway to extract or modify information from a given data structure.
`geometr` thus provides getters that provide information in identical arrangement from a wide range of classes, and likewise setters that modify many different classes in the same way, despite those classes typically need differently formatted input, arguments and functions.
The following code chunk shows how different input classes yield the same outpubt object.

```{r}
library(geometr)
myInput <- nc_sf
getExtent(x = myInput)

myInput <- nc_sp
getExtent(x = myInput)

myInput <- ras
getExtent(x = myInput)
```

The output of the tools provided by `geometr` is tidy, i.e. it provides variables in columns and observations in rows, and it is interoperable, i.e. it provides the same information in the same location of the output object, with the same names.
This ensures, amongst other advantages, that a custom function that processes geometric information, requires merely one very simple row of code to extract those information from a potentially wide range of distinct classes.

## Datastructure of the class `geom`

- three feature types
- all types have the same datastructure (i.e. it's interoperable, no slots are removed or added when modifying things)
- three tables, vertices, features and groups all can be joined with ancilliary data
- has a scale, which is either absolute or relative, the latter case then contains vertices relative to the reference window
- has a history slot that contains the provenance of a geom
- features are single closed paths
- multi* features are transformed to several (simpler) features and assigned the same group (some reasoning on that)
- geom contains only direct information, i.e. such information that can't be derived for example the extent
- has a reference window instead of an extent (like in spatstat)
- talk about tiny map
- talk about which advantages that brings, vertices are easily accessible and can be provided with attributes, which allows also point patterns to be treated together with other geometries
- somehow a hybrid of ppp and sf (units as in spatstat are indirectly covered by the projection)
- also describe that how a single features looks like (being close by a duplicate vertex and with holes that are inside)
- when making a geom from an sf, group = TRUE can be used to assign values that are unique at the level of multi_ features, into the groups attribute table, and not into the features attribute table, where they would be duplicated in a geom.
- the vert slot is comparable to the "geom" column in an sf, however, the values are easily and explicitly accessible and can be modified also with other functions or routines than the highly specific st_* functions.


## Casting

- cast by providing a geom in anchor of the respecive type
- it does not change anything about the data (check if that claim is really true), but merely changes the type.
- the type then determines how the object is plotted.
- when casting to polygon, the polygon checks are carried out.

## Visualising

- plot objects by providing a "the name = theObject".
- plot both, vector and raster objects
- methods extract the required information based on the above discussed getters, for any class that has getters defined (this still requires some work to be true for all classes)
- also explain how to use "window" for zooming and quick access to particular areas of a plot.

### Quick options

- attributes can be used in quick options

### The `gtTheme`

- explain how to set up a gtTheme
- there is a default gtTheme, which is modified with setTheme, which is kind of a setter, just not for geoms, but for gtTheme.
- explain how colour palettes work.

## Other tools in `geometr`

- tools are used feature-wise, if more than one set of modification values is provided. for example, if there are two features and two distinct angles of ration are provided, each feature will be rotated by the respective angle. When there are more features than angles, angles will be recycled.
- mention that those functions access the vertices